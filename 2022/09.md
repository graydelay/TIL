# 2022-09

## 2022-09-12
### 다대일[N:1] 단방향
- 가장 많이 사용하는 연관관계
- **다대일**의 반대는 **일대다**

### 다대일 양방향 정리
- 외래 키가 있는 쪽이 연관관계의 주인
- 양쪽을 서로 참조하도록 개발

### 일대다[1:N] 단방향
- 일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인
- 테이블 일대다 관계는 항상 다(N) 쪽에 외래 키가 있음
- 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조
- @JoinColumn을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함(중간에 테이블을 하나 추가함)
- 단점
    - 엔티티가 관리하는 외래 키가 다른 테이블에 있음
    - 연관관계 관리를 위해 추가로 UPDATE SQL 실행
- 일대다 단방향 매핑보다는 **다대일 양방향 매핑을 사용**하자

### 일대다 양방향
- 공식적으로 존재X
- `@JoinColumn(insertable = false, updatable = false)`
- 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법
- 다대일 양방향을 사용하자

## 2022-09-09
### JPA: 양방향 매핑 주의점 및 정리
- **순수 객체 상태를 고려해서 항상 양쪽에 값을 설정해야 한다**
- **단방향 매핑만으로도 이미 연관관계 매핑은 완료**
- 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 된다 (테이블에 영향을 주지 않음)
- 연관관계 편의 메소드를 설정해두는 것이 좋다

## 2022-09-08
### JPA 연관관계
#### 단방향 연관관계
- 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾는다
- 객체는 참조를 사용해서 연관된 객체를 찾는다
- 테이블과 객체 사이에는 이런 큰 간격이 있다

#### 양방향 연관관계
- @OneToMany(mappedBy = ””) : mappedBy 설정
- 반대 방향으로 객체 그래프 탐색
- mappedBy: 객체와 테이블간에 연관관계를 맺는 차이를 이해해야 한다
- 객체 연관관계: 단방향의 연관관계가 2개가 되면서 양방향 처럼 되는 것
- 둘 중 하나로 외래 키를 관리해야 한다 ⇒ 연관관계의 주인(Owner)

#### 연관관계의 주인
- **연관관계의 주인만이 외래 키를 관리(등록, 수정)**
- **주인이 아닌쪽은 읽기만 가능**
- 주인은 mappedBy 속성 사용X
- 주인이 아니면 mappedBy 속성으로 주인 지정
- 외래 키가 있는 곳을 주인으로 정해야 한다!! : 진짜 매핑 ← 연관관계의 주인

## 2022-09-07
### JPA 기본 키 매핑
- @Id: id를 직접 할당
- @GeneratedValue: 자동 생성
    - IDENTITY: 데이터베이스에 위임, MYSQL
        - AUTO_ INCREMENT는 데이터베이스에 INSERT SQL을 실행
        - IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행
        하고 DB에서 식별자를 조회
    - SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용, ORACLE
        - @SequenceGenerator 필요
        - insert 쿼리를 날리지 않아도 sequence를 이용하여 Id값을 알아 올 수 있기 때문에 IDENTITY와 달리 버퍼링이 가능
        - initialValue: DDL 생성 시에만 사용. 시퀀스 DDL을 생성할 때 처음 시작하는 수를 지정
        - allocationSize: 시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨)
    - TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용
        - @TableGenerator 필요
    - AUTO: 방언에 따라 자동 지정, 기본값
- **기본 키 권장: Long형 + 대체키 + 키 생성전략**

## 2022-09-06
### 영속성 컨텍스트
- “엔티티를 영구 저장하는 환경"이라는 뜻

### 영속성 컨텍스트의 이점
- 1차 캐시: 하나의 트랜젝션 안에서만 유효하긴 함
- 동일성(identity) 보장 : 1차 캐시가 있어서 가능
- 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind): 쓰기 지연 SQL 저장소
- 변경 감지(Dirty Checking)
- 지연 로딩(Lazy Loading)

### 플러시
- 영속성 컨텍스트의 변경내용을 데이터베이스에 반영
- 쌓아둔 sql(쓰기 지연 SQL)을 데이터베이스를 날림

### 준영속 상태
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리 (detached)
- 영속성 컨텍스트가 제공하는 기능을 사용 못함 (ex. dirty checking 등)

## 2022-09-05
### JPA: Java Persistence API
- 자바 진영의 ORM 기술 표준
- 패러다임 불일치를 해결해 줌

### ORM: Object-relational mapping(객체 관계 매핑)
- 객체는 객체대로 설계, 관계형 데이터베이스는 관계형 데이터베이스대로 설계
- ORM 프레임워크가 중간에서 매핑

### JPA Entity
- `EntityManagerFactory`: 하나만 생성하여 애플리케이션 전체에서 공유
- `EntityManager`: 쓰레드간에 공유X (사용하고 버려야 함)
- **JPA의 모든 데이터 변경은 트랜잭션 안에서 실행**

### JPQL
- JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공
- SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원
- **JPQL은 엔티티 객체**를 대상으로 쿼리
- **SQL은 데이터베이스 테이블**을 대상으로 쿼리
- SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않음
- JPQL === 객체 지향 SQL

## 2022-09-04
### production 모드
- DefinePlugin을 사용한다면 `process.env.NODE_ENV` 값이 `"development"`로 설정되어 어플리케이션에 전역변수로 주입. mode를 `"production"`으로 설정하면 자바스크립트 결과물을 최소화 하기 위해 다음 일곱 개 플러그인을 사용
  - FlagDependencyUsagePlugin
  - FlagIncludedChunksPlugin
  - ModuleConcatenationPlugin
  - NoEmitOnErrorsPlugin
  - OccurrenceOrderPlugin
  - SideEffectsFlagPlugin
  - TerserPlugin

### optimazation 속성으로 최적화
- `css-minimizer-webpack-plugin` : css 파일 압축
- `terser-webpack-plugin`: console.log와 같은 코드 제거

### Code Spliting 코드 스플리팅
- `SplitChunksPlugin` : 코드를 분리할 때 중복되는 코드를 별도의 파일로 분리하여 관리해준다

### Dynamic Import 다이나믹 임포트
- axios와 같은 패키지는 패키지로 제공될때 이미 빌드 과정을 거쳤기 때문에 빌드 프로세스에서 제외하는 것이 좋다. 웹팩 설정중 [externals](https://webpack.js.org/configuration/externals/) 이용 할 수 있다.
- axios는 이미 node_modules에 위치해 있기 때문에 이를 웹팩 아웃풋 폴더에 옮기고 index.html에서 로딩해야한다. 파일을 복사하는 [CopyWebpackPlugin](https://webpack.js.org/plugins/copy-webpack-plugin/)을 설치한다.

## 2022-09-03
### 웹팩 개발 서버
- ajax 방식의 api 연동은 `cors` 정책 때문에 반드시 서버가 필요
- 웹팩 개발 서버 : `webpack-dev-server`
- devServer 기본 설정
    ```js
    // webpack.config.js:
    module.exports = {
      devServer: {
        contentBase: path.join(__dirname, "dist"), // 정적파일을 제공할 경로. 기본값은 웹팩 아웃풋이다.
        publicPath: "/", // 브라우져를 통해 접근하는 경로. 기본값은 '/' 이다.
        host: "dev.domain.com",
        overlay: true, // 빌드시 에러나 경고를 브라우져 화면에 표시
        port: 8081, // 포트 설정
        stats: "errors-only", // 메세지 수준 설정
        historyApiFallback: true,
      },
    }
    ```

### API 연동
- 목업 API 1: `devServer.setupMiddlewares (webpack5)`
    - express.js의 app 객체를 가져올 수 있다
- 목업 API 2: `connect-api-mocker`
    - 목업 api 작업이 많을 때 특정 목업 폴더를 만들어 api 응답을 담은 파일을 저장한 뒤, 이 폴더를 api로 제공
- 목업 API 3: `proxy`
    - cors 문제를 해결하기 위해 proxy 설정을 사용

### Hot Module Replacement (HMR)
- 전체 화면 갱신 하지 않고 변경한 모듈만 바꿔치기 하는 기능
- 핫로딩을 지원하는 로더
    1. style-loader
    2. react-hot-loader
    3. file-loader

## 2022-09-01
### Lint
- ESLint: ESLint는 ECMAScript 코드에서 문제점을 검사하고 일부는 더 나은 코드로 정정하는 린트 도구 중의 하나
- Rules(규칙): ESLint는 검사 규칙을 미리 정해 놓았다. [Rules](https://eslint.org/docs/rules/) 문서에서 규칙 목록을 확인할 수 있음
- `.eslintrc.js` 파일에서 ESLint를 설정할 수 있으며. 위의 규칙들을 미리 정해 놓은 것들을 `extends`로 설정하면 여러 rules를 한번에 적용할 수 있다
- 자주 사용하는 extends
  1. `eslint:recommended`
  1. `airbnb`
  1. `standard`
### Prettier
- `Prettier`는 좀 더 일관적인 스타일로 코드를 다듬는다. 반면 코드 품질과 관련된 기능은 하지 않는 것이 ESLint와 다르다
### ESLint 와 Prettier 통합
1. `eslint-config-prettier`: [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier)는 프리티어와 충돌하는 ESLint 규칙을 끄는 역할
2. `eslint-plugin-prettier`: [eslint-plugin-prettier](https://github.com/prettier/eslint-plugin-prettier)는 프리티어 규칙을 ESLint 규칙으로 추가하는 플러그인이다. 프리티어의 모든 규칙이 ESLint로 들어오기 때문에 ESLint만 실행하면 된다.
- 위의 두개를 이용하여 eslint 설정파일에 plugin을 추가해 eslint와 prettier를 같이 실행 할 수 있다
### 자동화
- `husky` : pre-commit을 이용하여 git commit 전에 eslint를 자동으로 적용시킬 수 있다
- `lint-staged`: commit stage에 올라온 파일들에 대해 파일 규칙에 따라 `eslint`를 동작시킬 수 있다
- VSCode `setting.json`에 아래와 같이 설정해 놓으면 저장 할 때마다 eslint를 적용해서 파일을 변경해준다
  ```json
  {
    "editor.codeActionsOnSave": {
      "source.fixAll.eslint": true
    }
  }
  ```
