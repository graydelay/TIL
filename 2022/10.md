# 2022-10

## 2022-10-24
### Debounce(디바운스) / Throttle(스로틀) 공통점
1. DOM 이벤트를 기반으로 실행하는 자바스크립트를 성능상의 이유로 JS의 양적인 측면, 즉 이벤트(event)를 제어(제한)하는 방법
2. 이벤트 핸들러가 많은 연산을 수행하는 경우에 대해 제약을 걸어 제어할 수 있는 수준으로 이벤트를 발생 시키는 것을 목표로 한다

### Debounce
- 이벤트를 그룹화하여 특정시간이 지난 후 하나의 이벤트만 발생하도록 하는 기술
- 순차적 호출을 하나의 그룹으로 “그룹화”할 수 있다
- 연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출하도록 하는 것

### Throttle
- 이벤트를 일정한 주기마다 발생하도록 하는 기술
- Throttle의 설정시간으로 1ms를 주게되면 해당 이벤트는 1ms 동안 최대 한번만 발생하게 된다
- 마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 하는 것

### 차이점
- 스로틀은 적어도 X 밀리 초마다 정기적으로 기능 실행을 보장한다
- 디바운스는 아무리 많은 이벤트가 발생해도 모두 무시하고 특정 시간사이에 어떤 이벤트도 발생하지 않았을 때 한번만 마지막 이벤트를 발생시키는 기법.
- 따라서 5ms가 지나기 전에 계속 이벤트가 발생할 경우 콜백에 반응하는 이벤트는 발생하지 않고 계속 무시된다

## 2022-10-20
### JPA: API 개발 기본 
### 엔티티 직접 사용
- 문제점
    1. 엔티티에 프레젠테이션 계층을 위한 로직이 추가됨
    2. 엔티티에 API 검증을 위한 로직이 들어간다 (ex. `@NotEmpty`)
    3. 엔티티가 변경되면 API 스팩이 변한다
    4. 컬렉션 조회의 경우 컬렉션을 그대로 반환하게 되면 API 스펙을 변경하기가 어려움. 별도의 클래스 생성으로 해결해야 한다
- **API 요청 스펙에 맞추어 별도의 DTO를 파라미터로 사용한다**
- **실무에서는 엔티티를 API 스펙에 노출해서는 안된다!!!**

### PUT vs PATCH
- PUT은 전체를 업데이트 할 때 사용하는 것이 맞음
- 부분 업데이트를 할 때는 PATCH 또는 POST를 사용하는 것이 맞다

## 2022-10-16
### 도메인 모델 패턴 vs 트랜잭션 스크립트 패턴
- 도메인 모델 패턴
    - 엔티티가 비즈니스 로직을 가지고 객체 지향의 특성을 적극 활용
    - 비즈니스 로직 대부분이 엔티티에 있음
    - 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할
- 트랜잭션 스크립트 패턴
    - 엔티티에는 비즈니스 로직이 거의 없음
    - 서비스 계층에서 대부분의 비즈니스 로직을 처리하는 것

## 2022-10-12
### VSCode: launch.json
- VSCode에서 디버깅을 사용하기 위해서는 `launch.json` 파일이 필요
- Node.js 디버깅을 위한 기본파일은 아래와 같음
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Launch Program",
      "skipFiles": ["<node_internals>/**"],
      "program": "${workspaceFolder}\\app.js"
    }
  ]
}
```
- 위와 같이 설정한 후 Run을 실행하려하면 `package.json`에 설정된 명령어를 선택하여 실행할 수 있음
- 이후 디버깅 방식은 다른 IDE와 비슷

## 2022-10-10
### 테스트 코드 (Junit)

- 테스팅 코드에서 사용하는 Transaction은 테스트가 끝나면 모두 Rollback 된다
- 만약 테스트 이후에 Rollback이 되지 않기 원한다면 `@Rollback(value = false)` 를 사용하면 롤백 되지 않고 트랜젝션이 commit 된다

## 2022-10-06
### 다형성 쿼리
- TYPE: 조회 대상을 특정 자식으로 한정
- TREAT: 자바의 타입 캐스팅과 유사, 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용

### 엔티티 직접 사용
- JPQL에서 엔티티를 직접 사용하여 SQL에 `setParameter`하게 되면 SQL에서 해당 엔티티의 기본 키 값(id)를 사용하도록 쿼리가 변경된다
- 기본 키, 외래 키에 모두 사용 가능

## 2022-10-04
### JPQL: 경로 표현식
- .(점)을 찍어 객체 그래프를 탐색하는 것
- 상태 필드(state field): 단순히 값을 저장하기 위한 필드 (ex. m.username)
- 연관 필드(association field): 연관관계를 위한 필드
    - 단일 값 연관 필드: @ManyToOne, @OneToOne, 대상이 엔티티 (ex. m.tea)
    - 컬렉션 값 연관 필드: @OneToMany, @ManyToMany, 대상이 컬렉션 (ex. m.orders)

### 경로 표현식 특징
- 상태 필드: 경로 탐색의 끝, 탐색X
- 단일 값 연관 경로: 묵시적 내부 조인(inner join) 발생, 탐색O
- 컬렉션 값 연관 경로: 묵시적 내부 조인 발생, 탐색X
    - FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색 가능

### 명시적 조인, 묵시적 조인
- 명시적 조인: join 키워드 직접 사용
    - `select m from Member m join m.team t`
- 묵시적 조인: 경로 표현식에 의해 묵시적으로 SQL 조인 발생(내부 조인만 가능)
    - `select m.team from Member m`